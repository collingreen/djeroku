from coffin.shortcuts import HttpResponse
from django.core.paginator import Paginator, EmptyPage, InvalidPage
from django.utils.translation import ugettext as _, ungettext as _n
try: import simplejson as json
except ImportError: import json

def json_response(success, mimetype='application/json', **kwargs):
    """Accepts boolean success and any other keyword arguments
    and returns an HttpResponse with them all json encoded into
    a single object."""
    response = {'success': success}
    response.update(kwargs)
    return HttpResponse(json.dumps(response), mimetype=mimetype)

def raw_json_response(response, mimetype='application/json'):
    """Accepts an object and returns an HttpResponse
    with it encoded, using the specified mimetype or application/json."""
    return HttpResponse(json.dumps(response), mimetype=mimetype)

# this should probably be a decorator
def validate_required_exist(request, required_fields, check_get=False):
    """Accepts a list of fields and checks that they are
    available in the POST variable. If check_get is True,
    will also check for the fields in the GET variable before
    failing. If all the fields are found, returns True, otherwise
    returns the first missing field it finds."""
    for field in required_fields:
        if field not in request.POST and (not check_get or field not in request.GET):
            return field
    return True

def validate_required(request, required_fields_dict, all_failures=True,
                    check_get=False, quiet=False, error_messages=None):
    """
    Much more in depth validation of required fields. Accepts a dictionary
    in the form
    dict[field] = {
        'validation': function to validate value,
        'clean': function to clean value,
        'validation_failed_message': 'translated string WITH %s for field name',
        'validation_failed_message_raw': 'translated string WITHOUT %s for field name',
        'clean_failed_message': 'same as validation_failed_message but for clean' | True to use validation_failed_message,
        'clean_failed_message_raw': 'same as validation_failed_message_raw but for clean' | True to use validation_failed_message_raw
    }

    All of the keys for a field are optional. Missing fields will simply use defaults.

    If the validation function fails the error message will be generated by
        1. substituting the field name into validation_failed_message if available
        2. using the validation_failed_message_raw directly if available
        3. using the failed_validation error_message in the error_messages dict

    If the clean function fails the error message will be generated the same
    as the validation failures but using the clean messages first if available.
    As a convenience, the clean_failed_message and clean_failed_message_raw fields
    can be set to True which will simply duplicate the validation_failed_message
    and validation_failed_message_raw

    Each field will be checked that
        1. it exists in the POST variable (or GET if check_get is True)
        2. if a validation function is available, the function returns true when
            called with the value of the field
        3. if a clean function is available and no exception is raised when
            called with the value of the field

    If a field fails any test the function immediately returns a tuple with
    (False, field_that_failed, failure_reason). If quiet is True,
    only False will be returned. If all_failures is True, the function
    runs every test first and instead returns a tuple of
    (False, dict[field] = failure_reason) with every field that failed.

    If all the fields pass, each will be placed in a dictionary in the form
    clean_dict[field] = output_of_clean_function. If no clean function
    is given for a field, it is returned raw.

    If no errors are found, the function returns (True, clean_dict). If quiet
    is True, returns just the clean_dict.

    Translatable error messages are included, but you can pass in a dictionary
    of your own translated error messages if you want to customize the output.

    Basic Usage Example:
        required_fields = {
            'object_id': {'validation': lambda a: a.isdigit(), 'clean': lambda a: int(a) },
            'object_type': {'validation': lambda a: a.isalnum() and a.strip() != '', 'clean': lambda a: a.strip() }
        }
        clean = validate_required(request, required_fields)
        if not clean[0]:
            return <some failure response here>

    Todo:
        tests:
            no validation, no clean
                with check_get
                with default error_messages
                with given error_messages

            validation only
                with check_get
                with failed message
                with failed message raw
                with default message
                with given error_messages

            clean only
                with check_get
                with clean failed message
                with clean failed raw
                with clean failed message = True
                with clean failed raw = True
                with default message
                with given error_messages

            validation and clean
                all above tests with failing one, then the other
    """

    if error_messages is None:
        error_messages = {
            'missing_field': _('Missing Required Field'),
            'failed_validation': _('Validation Failed'),
            'failed_clean': _('Validation Failed')
        }

    failures = {}
    clean = {}

    for field, field_info in required_fields.iteritems():
        # check that field exists
        if field not in request.POST and (not check_get or field not in request.GET):
            if all_failures:
                failures[field] = error_messages['missing_field']
                continue
            elif quiet: return False
            else: return (False, field, error_messages['missing_field'])

        # get field from post or get
        if field in request.POST:
            field_raw_value = request.POST[field]
        elif field in request.GET:
            field_raw_value = request.GET[field]

        # validate field if function is available
        if 'validation' in field_info and not field_info['validation'](field_raw_value):

            # get correct validation failure message
            message = error_messages['validation_failed']
            if 'validation_failed_message' in field_info:
                try:
                    message = field_info['validation_failed_message'] % field
                except: pass
            elif 'validation_failed_message_raw' in field_info:
                message = field_info['validation_failed_message_raw']

            if all_failures:
                failures[field] = message
                continue
            elif quiet: return False
            else: return (False, field, message)

        # clean field if function is available
        if 'clean' in field_info:
            try:
                clean[field] = field_info['clean'](field_raw_value)
            except:
                # get correct clean failure message
                message = error_messages['clean_failed']
                if 'clean_failed_message' in field_info:
                    if field_info['clean_failed_message'] is True and 'validation_failed_message' in field_info:
                        message_base = field_info['validation_failed_message']
                    else:
                        message_base = field_info['clean_failed_message']

                    try:
                        message = message_base % field
                    except: pass
                elif 'clean_failed_message_raw' in field_info:
                    if field_info['clean_failed_message_raw'] is True:
                        message = field_info['validation_failed_message_raw']
                    else:
                        message = field_info['clean_failed_message_raw']

                # save message/return failure
                if all_failures:
                    failures[field] = message
                    continue
                elif quiet: return False
                else: return (False, field, message)

        # no clean function, use raw
        else:
            clean[field] = field_raw_value

    # failures
    if len(failures) > 0:
        return (False, failures)

    # no failures, return clean field dict
    if quiet:
        return clean
    else:
        return (True, clean)
		

# http://www.lightbird.net/dbe/forum1.html
def create_paginator(request, items, num_items):
    """Create and return a paginator."""
    paginator = Paginator(items, num_items)
    try: page = int(request.GET.get("page", '1'))
    except ValueError: page = 1

    try:
        items = paginator.page(page)
    except (InvalidPage, EmptyPage):
        items = paginator.page(paginator.num_pages)
    return items